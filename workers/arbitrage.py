from __future__ import annotations

from decimal import Decimal

from const.controlls import minRoiRequirement
from factory.w3 import W3
from handlers.erc20 import ERC20
from handlers.pancakeSwapRouter import PancakeSwapRouter
from workers.graph import Graph
from time import sleep, time
import math


last_approval = {
    "amount": None,
    "exchange": None
}


def clear_last_approval():
    last_approval["exchange"] = None
    last_approval["amount"] = None


def should_execute(path, min_output) -> bool:
    if len(path) < 2:
        return False
    print("Simulated roi from dex", min_output[-1] / min_output[0], min_output[-1] / min_output[0] > 1.001)
    if min_output[-1] / min_output[0] < minRoiRequirement():
        return False
    return True


def get_path_expected_output(graph: Graph, path: list[str]) -> list[int]:
    expected_output_value = [graph.tradeSize]
    for step in path:
        reserve = graph.edges[step]
        out = ((reserve[1] / reserve[0]) * expected_output_value[-1])
        out -= out * 0.001
        expected_output_value.append(
            out
        )
    return expected_output_value


def simulate_execute_arbitrage(graph: Graph, path: list[str], optimal_amount: int) -> list[int]:
    circuit = getSwapCircuit(path, [0] * len(path))
    expected_output_value = [optimal_amount]
    for i in range(len(circuit)):
        phase = circuit[i]
        swap = phase['swap']
        router = PancakeSwapRouter(swap)
        out = router.getAmountsOut(expected_output_value[-1], phase["path"])
        expected_output_value += out
    return expected_output_value


def getSwapCircuit(path: list[str], expected_output: list[int]) -> list[dict[str, list[str] | list[int]]]:
    circuit = []
    last_swap = None
    p = -1
    for i in range(len(path)):
        step = path[i]
        a = step.split("_")[0]
        b = step.split("_")[1]
        swap = step.split("_")[2]
        if swap != last_swap:
            last_swap = swap
            p += 1
            circuit.append({
                "path": [a],
                "expected_output": [expected_output[i]],
                "swap": swap
            })
            if p > 0:
                circuit[p - 1]['path'].append(a)
                circuit[p - 1]['expected_output'].append(expected_output[i])
        else:
            circuit[p]['path'].append(a)
            circuit[p]['expected_output'].append(expected_output[i])

    b = path[-1].split("_")[1]
    circuit[-1]['path'].append(b)
    circuit[-1]['expected_output'].append(expected_output[-1])
    return circuit


def execute_arbitrage(path: list[str], min_output: list[int], optimal_trade_size: int):
    print("min output (generated by simulation)", min_output)

    circuit = getSwapCircuit(path, min_output)
    if len(circuit) == 1:
        execute_arbitrage_single_exchange(path, min_output, optimal_trade_size)
    else:
        prev = min_output[0]
        for i in range(len(circuit)):
            phase = circuit[i]

            print("Starting step", i + 1, "of", len(circuit), "for", phase['path'], phase['swap'])
            a = phase['path'][0]
            tokenA = ERC20(a)
            new_in_amnt_a = optimal_trade_size
            if i > 0:
                new_in_amnt_a = tokenA.getBalance(W3().executor_wallet)
            new_out_amnt_b = (new_in_amnt_a / phase['expected_output'][0]) * phase['expected_output'][-1]
            phase['expected_output'][-1] = new_out_amnt_b
            swap = phase['swap']

            router = PancakeSwapRouter(swap)
            sleep_duration = 3
            while True: # 3 retries
                try:
                    # approve transaction
                    if last_approval["exchange"] != swap and last_approval["amount"] != new_in_amnt_a:
                        last_approval["exchange"]
                        tokenA.approve(swap, new_in_amnt_a)
                    # place transaction
                    try:
                        router.swapExactTokensForTokens(
                            int(new_in_amnt_a),
                            int(new_out_amnt_b),
                            phase['path'],
                            W3().executor_wallet,
                            int(time() + 20)
                        )
                        clear_last_approval()
                    except Exception as e:
                        # get out of the position at all cost, dont want to be stuck with the bag
                        print(e)
                        if i == 0:
                            print("exiting execution before money is lost")
                            return
                        if last_approval["exchange"] != swap and last_approval["amount"] != new_in_amnt_a:
                            tokenA.approve(swap, new_in_amnt_a)
                        for j in range(i, len(circuit)):
                            circuit[j]['expected_output'][-1] = circuit[j]['expected_output'][
                                                                    -1] * 0.95  # take up to a 10% loss, to avoid being stuck with crap
                        new_out_amnt_b = phase['expected_output'][-1]
                        router.swapExactTokensForTokens(
                            int(new_in_amnt_a),
                            int(new_out_amnt_b),
                            phase['path'],
                            W3().executor_wallet,
                            int(time() + 20)
                        )
                        clear_last_approval()
                    break
                except Exception as e:
                    sleep_duration += 1
                    sleep(sleep_duration)
                    print(f"sleeping for {sleep_duration} seconds")
            if i + 1 == len(circuit):
                print(
                    f"expected output: {new_out_amnt_b} => " +
                    f"actual output: {ERC20(phase['path'][-1]).getBalance(W3().executor_wallet)}")
            prev = min_output[i + 1]
            print("completed step", i + 1, "of", len(circuit), "for", phase['path'], phase['swap'])


def execute_arbitrage_single_exchange(path: list[str], min_output: list[int], optimal_trade_size: int):
    print("min output (generated by simulation)", min_output)

    circuit = getSwapCircuit(path, min_output)
    phase = circuit[0]
    print("Starting trade", "for", phase['path'], phase['swap'])
    a = phase['path'][0]
    tokenA = ERC20(a)
    new_in_amnt_a = optimal_trade_size
    new_out_amnt_b = phase['expected_output'][-1]
    phase['expected_output'][-1] = new_out_amnt_b
    swap = phase['swap']
    router = PancakeSwapRouter(swap)
    # approve transaction
    if last_approval["exchange"] != swap and last_approval["amount"] != new_in_amnt_a:
        last_approval["exchange"] = swap
        last_approval["amount"] = new_in_amnt_a
        tokenA.approve(swap, new_in_amnt_a)
    # place transaction
    for reduction in [1, 0.9999, 0.999]:
        new_out_amnt_b = phase['expected_output'][-1] * reduction
        if new_out_amnt_b <= new_in_amnt_a:
            print(f"Profitability too low. input: {new_in_amnt_a}, output: {new_out_amnt_b}")
            return
        try:
            router.swapExactTokensForTokens(
                int(new_in_amnt_a),
                int(new_out_amnt_b),
                phase['path'],
                W3().executor_wallet,
                int(time() + 20)
            )
            clear_last_approval()
            return
        except Exception as e:
            if e.args[0]["message"] == 'execution reverted: WagyuRouter: INSUFFICIENT_OUTPUT_AMOUNT':
                pass
            else:
                print("execution failed for unhandled reason")
                print(e)
                return
    print(
        f"expected output: {new_out_amnt_b} => " +
        f"actual output: {ERC20(phase['path'][-1]).getBalance(W3().executor_wallet)}")
    print("completed execution successfully for", phase['path'], phase['swap'])


def getEaEb(graph: Graph, pairs):
    Ea = None
    Eb = None
    idx = 0
    tokenIn = pairs[0].split("_")[0]
    tokenOut = tokenIn
    for pair in pairs:
        if idx == 0:
            if tokenIn == pair.split("_")[0]:
                tokenOut = pair.split("_")[1]
            else:
                tokenOut = pair.split("_")[0]
        if idx == 1:
            reserve = graph.edges[pair]
            Ra = reserve[0]
            Rb = reserve[1]
            if tokenIn == pairs[0].split("_")[1]:
                temp = Ra
                Ra = Rb
                Rb = temp
            Rb1 = reserve[0]
            Rc = reserve[1]
            if tokenOut == pair.split("_")[1]:
                temp = Rb1
                Rb1 = Rc
                Rc = temp
                tokenOut = pair.split("_")[0]
            else:
                tokenOut = pair.split("_")[1]
            Ea = 1000*Ra*Rb1/(1000*Rb1+997*Rb)
            Eb = 997*Rb*Rc/(1000*Rb1+997*Rb)
        if idx > 1:
            Ra = Ea
            Rb = Eb
            reserve = graph.edges[pair]
            Rb1 = reserve[0]
            Rc = reserve[1]
            if tokenOut == pair.split("_")[1]:
                temp = Rb1
                Rb1 = Rc
                Rc = temp
                tokenOut = pair.split("_")[0]
            else:
                tokenOut = pair.split("_")[1]
            Ea = 1000*Ra*Rb1/(1000*Rb1+997*Rb)
            Eb = 997*Rb*Rc/(1000*Rb1+997*Rb)
        idx += 1
    return Ea, Eb


def getOptimalAmount(graph: Graph, pairs, ):
    Ea, Eb = getEaEb(graph, pairs)
    if Ea > Eb:
        return None
    return int((Decimal(math.sqrt(Ea*Eb*Decimal(997*1000)))-Ea*Decimal(1000))/Decimal(997))
